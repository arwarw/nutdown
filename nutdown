#!/usr/bin/env perl

use warnings;
use strict;
use Sys::Syslog;
use Sys::Hostname;
use Config::General qw(ParseConfig);
use UPS::Nut;
use IPC::Run qw(run);
use Data::Dumper qw(Dumper);

my $configfile = $ARGV[0] // "/etc/nutdown/nutdown.conf";
my $conf = create_hostconfig($configfile);

if (grep {m/^--dump-config$/} @ARGV) {
	use Data::Dumper qw(Dumper);
	print Dumper($conf);
	exit;
}

$SIG{CHLD} = "IGNORE";
my $ups;
$ups = maybe_connect_to_ups();

if (! $ups) {
	die "could not connect to UPS: $!";
}

unless(fork()) {
	openlog("nutdown", "pid,perror", "daemon");
	syslog("notice", "starting up with config $configfile, polling every ". $conf->{poll_interval}. "s");

	my $last_state = '';
	my $last_charge = 100;

	while (1 == 1) {
		if (! $ups->{srvsock}) {
			$ups = maybe_connect_to_ups();
		}

		my $status;
		$status = $ups->Status();

		if (not defined($status)) {
			syslog "notice", "no status";
			sleep($conf->{poll_interval});
			next;
		}

		if ($status =~ m/FSD/) {
			# forced shutdown state, UPS will cut power soon
			execute_action($conf->{event}->{forced_shutdown});
		}

		if ($status =~ m/^OB/) {
			# on battery

			if ($last_state ne 'OB') {
				execute_action($conf->{event}->{power_fail});
			}

			my $battery = $ups->BattPercent();
			if (defined($battery)) {
				if ($battery != $last_charge) {
					my $i;
					for ($i = $last_charge; $i > $battery; $i--) {
						# execute all actions between the last known battery charge and the current charge
						if (exists($conf->{event}->{$i})) {
							execute_action($conf->{event}->{$i});
						}
					}
				}
				$last_charge = $battery + 0; # we want a sane number, no leading zeroes or stuff, so force a cast
			} else {
				if ($last_state eq 'OB') {
					# we didn't get a percentage twice, do something
					execute_action($conf->{event}->{unknown_percentage});
				} else {
					# we didn't get a percentage once, that may be bad
				}
			}
			$last_state = 'OB';
		} elsif ($status =~ m/^OL/) {
			# on line power

			if ($last_state ne 'OL') {
				# power has returned recently
				execute_action($conf->{event}->{power_return});
			}

			$last_state = 'OL';
			$last_charge = 100; # set to 100 so the next powerfail will always execute all the powerfail and percentage actions from 100 down to the current percentage
		} else {
			# some unknown status

			if ($last_state ne 'unknown_status') {
				syslog("warning", "reconnecting because of unparseable status ". $status // "undef");
				execute_action($conf->{event}->{unknown_status});
				$last_state = 'unknown_status';
			}
		}

		sleep($conf->{poll_interval});
	}
# }

exit 0;

sub execute_action {
	my $action = shift;
	if (defined $action) {
		if ($action->{syslog}) {
			syslog("info", $action->{syslog});
		}

		$ups->Logout(); # close ups connection before fork()ing, UPS::Nut crashes if we don't
		if ($action->{exec}) {
			unless(fork()) {
				run $action->{exec};
				exit 0;
			}
		}
	}
}

sub maybe_connect_to_ups {
	my $ret =  new UPS::Nut(NAME => $conf->{ups}->{name},
				HOST => $conf->{ups}->{host},
				PORT => $conf->{ups}->{port},
				USERNAME => $conf->{ups}->{username},
				PASSWORD => $conf->{ups}->{password},
				TIMEOUT => $conf->{ups}->{timeout});

	unless (defined($ret)) {
		syslog("err", "could not connect to ups ". $conf->{ups}->{name} // "undef");
		return undef;
	}

	return $ret;
}

sub create_hostconfig 
{	
	my $configfile = shift;
	my $host = hostname();
	my %conf;
	my $defaultconfig = {
		poll_interval => 30,
	};
	
	%conf = ParseConfig(-ConfigFile => $configfile, -DefaultConfig => $defaultconfig, -MergeDuplicateBlocks => 1, -MergeDuplicateOptions => 1);
	if (exists $conf{$host}) {
		if (exists $conf{$host}->{group} and exists $conf{group} and exists $conf{group}->{$conf{$host}->{group}}) {
			%conf = ParseConfig(-ConfigHash => $conf{group}->{$conf{$host}->{group}}, -DefaultConfig => \%conf, -MergeDuplicateBlocks => 1, -MergeDuplicateOptions => 1);
		}
		%conf = ParseConfig(-ConfigHash => $conf{$host}, -DefaultConfig => \%conf, -MergeDuplicateBlocks => 1, -MergeDuplicateOptions => 1);
	}

	return \%conf;
}
