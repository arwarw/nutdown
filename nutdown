#!/usr/bin/env perl

use warnings;
use strict;
use Sys::Syslog;
use Sys::Hostname;
use Config::General qw(ParseConfig);
use UPS::Nut;
use IPC::Run qw(run);
use Data::Dumper qw(Dumper);

my $configfile = $ARGV[0] // "/etc/nutdown/nutdown.conf";
my $conf = create_hostconfig($configfile);

if (grep {m/^--dump-config$/} @ARGV) {
	use Data::Dumper qw(Dumper);
	print Dumper($conf);
	exit;
}

$SIG{CHLD} = "IGNORE";
my $ups;
$ups = maybe_connect_to_ups();

if (! $ups) {
	die "could not connect to UPS: $!";
}

#unless(fork()) {
	openlog("nutdown", "pid,perror", "daemon");
	syslog("notice", "starting up with config $configfile");

	my $last_state = '';

	print Dumper($ups);

	while (1) {
		if (! defined($ups)) {
			$ups = maybe_connect_to_ups();
		}

		if ((! defined($ups)) or (! $ups->{srvsock}->connected())) {
			sleep($conf->{poll_interval});
			next;
		}

		# UPS::Nut isa IO::Socket::INET
		if (! $ups->{srvsock}->connected()) {
			sleep($conf->{poll_interval});
			next;
		}

		my $status = $ups->Status();

		print Dumper($status);

		if (not defined($status)) {
			syslog "notice", "no status";
			sleep($conf->{poll_interval});
			next;
		}

		if ($status =~ m/FSD/) {
			# forced shutdown state, UPS will cut power soon
			execute_action($conf->{event}->{forced_shutdown});
		}

		if ($status =~ m/^OB/) {
			# on battery

			my $battery = $ups->BattPercent();
			if (defined($battery)) {
				if ($battery != $last_state) {
					# FIXME: this does only work if we hit one percentage exactly, which is unlikely
					execute_action($conf->{event}->{$battery});
				}
				$last_state = $battery + 0; # we want a sane number, no leading zeroes or stuff, so force a cast
			} else {
				if ($last_state eq 'OB') {
					# we didn't get a percentage twice, do something
					execute_action($conf->{event}->{unknown_percentage});
				} else {
					# we didn't get a percentage once, that may be bad
					$last_state = 'OB';
				}
			}
		} elsif ($status =~ m/^OL/) {
			# on line power

			if ($last_state ne 'OL') {
				# power has returned recently
				execute_action($conf->{event}->{power_return});
			}

			$last_state = 'OL';
		} else {
			# some unknown status

			if ($last_state ne 'unknown_status') {
				syslog("warning", "reconnecting because of unparseable status ". $status // "undef");
				execute_action($conf->{event}->{unknown_status});
				$last_state = 'unknown_status';

				$ups = maybe_connect_to_ups();
			}
		}

		sleep($conf->{poll_interval});
	}
# }

exit 0;

sub execute_action {
	my $action = shift;
	if (defined $action) {
		if ($action->{syslog}) {
			syslog("info", $action->{syslog});
		}

		if ($action->{exec}) {
			unless(fork()) {
				run $action->{exec};
			}
		}
	}
}

sub maybe_connect_to_ups {
	my $ret =  new UPS::Nut(NAME => $conf->{ups}->{name},
				HOST => $conf->{ups}->{host},
				PORT => $conf->{ups}->{port},
				USERNAME => $conf->{ups}->{username},
				PASSWORD => $conf->{ups}->{password},
				TIMEOUT => $conf->{ups}->{timeout});

	unless (defined($ret)) {
		syslog("err", "could not connect to ups ". $conf->{ups}->{name} // "undef");
		return undef;
	}

	return $ret;
}

sub create_hostconfig 
{	
	my $configfile = shift;
	my %fconf = ParseConfig($configfile);
	my $host = hostname();
	my $ret;
	my $defaultconfig = {
		poll_interval => 30,
	};

	$ret = copy_if_defined($fconf{host}->{$host}, $ret);
	if (defined($fconf{host}->{$host}->{group})) {
		$ret = copy_if_defined($fconf{group}->{$fconf{host}->{$host}->{group}}, $ret);
	}
	$ret = copy_if_defined($fconf{default}, $ret);
	$ret = copy_if_defined($defaultconfig, $ret);

	return $ret;
}

sub copy_if_defined
{
	my ($a, $b) = @_;

	for (keys %{$a}) {
		unless (exists($b->{$_})) {
			$b->{$_} = $a->{$_};
		}
	}

	return $b;
}
